@page "/Watch"

@using System.Collections.Generic
@using PPather.Data
@using PPather.Graph
@using System.Threading
@using System.Numerics
@using SharedLib.Extensions
@using WowTriangles
@using System.Text.Json
@using SharedLib.Converters

@implements IDisposable

@inject ILogger logger
@inject IJSRuntime jsRuntime
@inject PPatherService pPatherService

@*
<button @onclick="ResetService">
    <span>Reset</span>
</button>
*@
<div id="canvasText" style="position: relative; z-index: 2; left: 0px;padding-left:10px; top: 20px; height:30px; background-color: black;color:white">
    ...
</div>
<canvas id="renderCanvas" style="background:black">
</canvas>
@code {

    private bool initialised = false;
    private Thread RefreshSearchThread;
    private CancellationTokenSource cts;

    [Parameter]
    public int PathColour { get; set; } = 1;

    [Parameter]
    public string Name { get; set; } = "path";

    private JsonSerializerOptions options;

    private Vector3 lastFrom = new();
    private Vector3 lastTo = new();
    private Vector3 lastClosest = new();
    private Vector3 lastPeek = new();

    public void Dispose()
    {
        PathingAPILoggerSink.OnLog -= Log;

        pPatherService.OnReset = null;
        pPatherService.SetNotifyChunkAdded(null);
        pPatherService.SetOnPathCreated(null);

        pPatherService.OnLinesAdded = null;
        pPatherService.OnSphereAdded = null;

        cts?.Cancel();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            options = new();
            options.Converters.Add(new Vector3Converter());
            options.Converters.Add(new Vector4Converter());

            PathingAPILoggerSink.OnLog += Log;
            await jsRuntime.InvokeVoidAsync("createScene");
            Initialise();
        }
    }

    private async void Initialise()
    {
        if (!pPatherService.HasInitialised)
        {
            await jsRuntime.InvokeVoidAsync("log", "Waiting for first search from the API...");
        }
        else
        {
            initialised = true;
            pPatherService.SetNotifyChunkAdded(TriangleWorld_NotifyChunkAdded);

            if (pPatherService.SearchExists)
            {
                this.AddChunks(pPatherService.GetLoadedChunks());
            }

            cts = new();
            pPatherService.SetOnPathCreated(DrawFinalPath);
            RefreshSearchThread = new Thread(SearchPathRefresh);
            RefreshSearchThread.Start();

            pPatherService.OnReset = Reset;
            pPatherService.OnLinesAdded = Drawlines;
            pPatherService.OnSphereAdded = DrawSphere;
        }
    }

    public async void Reset()
    {
        await jsRuntime.InvokeVoidAsync("clear");
    }

    public async void ResetService()
    {
        pPatherService.Reset();
        await jsRuntime.InvokeVoidAsync("clear");
    }

    public async void Log(object s, string message)
    {
        await jsRuntime.InvokeVoidAsync("log", message);
        if (!initialised)
        {
            Initialise();
        }
    }

    public async void DrawFinalPath(Path spotPath)
    {
        if (spotPath != null)
        {
            await jsRuntime.InvokeVoidAsync("removeMeshes", Name);
            await jsRuntime.InvokeVoidAsync("drawPath",
                JsonSerializer.Serialize(spotPath.locations, options), PathColour, Name);

            await jsRuntime.InvokeVoidAsync("removeMeshes", "search");
            await jsRuntime.InvokeVoidAsync("removeMeshes", "closest");
            await jsRuntime.InvokeVoidAsync("removeMeshes", "end");
        }
        else
        {
            Log(this, "No path found");
        }
    }

    public async void SearchPathRefresh()
    {
        while (!cts.IsCancellationRequested)
        {
            if (PPather.Graph.PathGraph.SearchEnabled)
            {
                try
                {
                    var spots = pPatherService.GetCurrentSearchPath();
                    if (spots != null)
                    {
                        var path = spots.Where(s => s != null).Select(s => s.Loc);
                        if (path.Count() > 0)
                        {
                            await jsRuntime.InvokeVoidAsync("drawPath",
                                JsonSerializer.Serialize(path, options), 4, "search");
                        }
                    }

                    if (pPatherService.SearchFrom.HasValue && pPatherService.SearchTo.HasValue &&
                        lastFrom.X != pPatherService.SearchFrom.Value.X)
                    {
                        lastFrom = pPatherService.SearchFrom.Value.AsVector3();
                        lastTo = pPatherService.SearchTo.Value.AsVector3();

                        await jsRuntime.InvokeVoidAsync("drawLine",
                            JsonSerializer.Serialize(lastFrom, options), 2, "start2");
                        await jsRuntime.InvokeVoidAsync("drawLine",
                            JsonSerializer.Serialize(lastTo, options), 3, "end");
                    }

                    if (pPatherService.ClosestLocation.HasValue &&
                        lastClosest.X != pPatherService.ClosestLocation.Value.X)
                    {
                        await jsRuntime.InvokeVoidAsync("drawLine",
                            JsonSerializer.Serialize(pPatherService.ClosestLocation.Value, options), 5, "closest");
                        lastClosest = pPatherService.ClosestLocation.Value;
                    }

                    if (pPatherService.PeekLocation.HasValue && lastPeek.X != pPatherService.PeekLocation.Value.X)
                    {
                        await jsRuntime.InvokeVoidAsync("drawLine",
                            JsonSerializer.Serialize(pPatherService.PeekLocation.Value, options), 6, "peek");
                        lastPeek = pPatherService.PeekLocation.Value;
                    }

                }
                catch (Exception ex)
                {
                    Log(this, ex.Message);
                }
            }
            cts.Token.WaitHandle.WaitOne(50);
        }
        logger.LogInformation("SearchPathRefresh thread stopped!");
    }

    private async void DrawSphere(SphereEventArgs e)
    {
        await jsRuntime.InvokeVoidAsync("drawSphere",
            JsonSerializer.Serialize(e.Location, options), e.Colour, e.Name);
    }

    private async void Drawlines(LinesEventArgs e)
    {
        await jsRuntime.InvokeVoidAsync("drawPath",
            JsonSerializer.Serialize(e.Locations, options), e.Colour, e.Name);
    }

    private void TriangleWorld_NotifyChunkAdded(ChunkAddedEventArgs e)
    {
        AddChunks(new() { e.Triangles });
    }

    private async void AddChunks(List<TriangleCollection> chunks)
    {
        Vector3[] positions = MeshFactory.CreatePointList(chunks);
        int[] water = MeshFactory.CreateTrianglesList(1, chunks);
        //FixMaxWaterHeight(water, positions);

        List<int[]> models = new();
        models.Add(MeshFactory.CreateTrianglesList(0, chunks));
        models.Add(water);
        models.Add(MeshFactory.CreateTrianglesList(2, chunks));
        models.Add(MeshFactory.CreateTrianglesList(4, chunks));

        await jsRuntime.InvokeVoidAsync("addModels",
            JsonSerializer.Serialize(models),
            JsonSerializer.Serialize(positions, options));
    }

    private void FixMaxWaterHeight(int[] waterPoints, Vector3[] positions)
    {
        List<float> zlist = waterPoints.Select(pt => positions[pt].Z).ToList();
        if (zlist.Count > 1)
        {
            float minz = zlist.Min();
            for (int i = 0; i < waterPoints.Length; i++)
            {
                waterPoints.ToList().ForEach(i =>
                {
                    if (positions[i].Z > minz) { positions[i].Z = minz; }
                });
            }
        }
    }
}